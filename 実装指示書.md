 Nuxt 2 to Nuxt 3 アップグレード実装指示書

  1. はじめに

  このドキュメントは、現在の Nuxt 2 プロジェクトを Nuxt 3 へアップグレードするための手順を定義します。アップグレードにより、Vite による高速な開発サーバー、Nitro
  によるサーバーサイド機能の強化、Composition API の全面的なサポートなどの恩恵を受けることができます。

  1.1. 現状のアーキテクチャ概要

   - フレームワーク: Nuxt.js v2
   - レンダリング: SPAモード (ssr: false)
   - 状態管理: Vuex (store/ ディレクトリ)
   - UI制御: pages/index.vue が Vuex の状態に応じて List コンポーネントと Detail コンポーネントを動的に切り替える。
   - API通信: @nuxtjs/axios を利用し、Vuex ストア内で API 通信を管理。
   - 共通ロジック: components/mixin.js を使用して、複数のコンポーネントでロジックを共有。

  1.2. アップグレード方針

   - 状態管理: Vuex から Pinia へ移行します。Pinia は Vue 3 の公式状態管理ライブラリであり、Nuxt 3 との親和性が高いです。
   - API通信: @nuxtjs/axios を廃止し、Nuxt 3 に組み込まれている `useFetch` またはグローバルな `$fetch` を利用します。
   - 共通ロジック: mixin.js を廃止し、Composition API の `composables` にロジックを切り出します。
   - コンポーネント: 全てのコンポーネントで <script setup> 構文を全面的に採用し、コードの可読性と再利用性を向上させます。
   - ディレクトリ構造: Nuxt 3 の規約に合わせてディレクトリ構造を更新します (static -> public など)。

  2. アップグレード手順

  ステップ 1: 準備

   1. ブランチの作成:
      作業用に新しいブランチを作成します。
   1     git checkout -b feature/nuxt3-upgrade

   2. node/npm のバージョン確認:
      Nuxt 3 は Node.js v16.11.0 以上を推奨しています。必要に応じてバージョンアップしてください。

  ステップ 2: 依存関係の更新

   1. `package.json` の編集:
      依存関係を Nuxt 3 対応のものに更新します。

      削除するパッケージ:
       - nuxt
       - @nuxtjs/axios
       - nuxt-start

      追加/更新するパッケージ:
       - nuxt: ^3.x.x
       - @pinia/nuxt: Pinia を Nuxt で使うためのモジュール
       - eslint-plugin-vue: 最新版
       - @nuxtjs/eslint-config-typescript: Nuxt 3 + TypeScript 用の ESLint 設定

      変更後の `devDependencies` (例):

   1     "devDependencies": {
   2       "@nuxt/devtools": "latest",
   3       "@nuxtjs/eslint-config-typescript": "^12.0.0",
   4       "eslint": "^8.44.0",
   5       "eslint-plugin-vue": "^9.15.1",
   6       "nuxt": "^3.6.5",
   7       "sass": "^1.63.6",
   8       "@pinia/nuxt": "^0.4.11"
   9     }
      ※バージョンは最新のものを確認して設定してください。

   2. 依存関係の再インストール:
      node_modules と package-lock.json を削除し、再インストールします。
   1     rm -rf node_modules package-lock.json
   2     npm install

  ステップ 3: 設定ファイルの移行

   1. `nuxt.config.js` -> `nuxt.config.ts`:
      ファイル名を変更し、内容を Nuxt 3 の defineNuxtConfig を使った形式に書き換えます。

    1     // nuxt.config.ts
    2     export default defineNuxtConfig({
    3       // 開発ツールを有効化
    4       devtools: { enabled: true },
    5
    6       // SPAモードの設定
    7       ssr: false,
    8
    9       // CSS の設定
   10       css: ['@/assets/sass/style.scss'],
   11
   12       // モジュールの設定
   13       modules: [
   14         '@pinia/nuxt',
   15       ],
   16
   17       // アプリケーションの head タグ設定
   18       app: {
   19         head: {
   20           title: 'Weather App',
   21           meta: [
   22             { charset: 'utf-8' },
   23             { name: 'viewport', content: 'width=device-width, initial-scale=1' },
   24             { hid: 'description', name: 'description', content: 'Nuxt.js Weather App' }
   25           ],
   26           link: [
   27             { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }
   28           ]
   29         }
   30       },
   31
   32       // APIプロキシや環境変数の設定 (必要に応じて)
   33       runtimeConfig: {
   34         public: {
   35           weatherApiBaseUrl: 'https://weather.tsukumijima.net'
   36         }
   37       }
   38     })

   2. `.eslintrc.js` の更新:
      Nuxt 3 と TypeScript に合わせた設定に更新します。

    1     module.exports = {
    2       root: true,
    3       env: {
    4         browser: true,
    5         node: true
    6       },
    7       extends: [
    8         '@nuxtjs/eslint-config-typescript',
    9         'plugin:vue/vue3-recommended'
   10       ],
   11       rules: {
   12         // 必要に応じてルールを追加
   13       }
   14     }

   3. `jsconfig.json` -> `tsconfig.json`:
      Nuxt 3 は TypeScript を標準サポートしているため、tsconfig.json を作成します。npm run dev を一度実行すると、Nuxt が自動的に .nuxt/tsconfig.json
  を生成します。これをプロジェクトルートにコピーしてカスタマイズのベースとします。

   1     # 開発サーバーを一度起動して tsconfig を生成させる
   2     npm run dev
   3     # (Ctrl+Cで停止)
   4     cp .nuxt/tsconfig.json .

  ステップ 4: ディレクトリとファイルの移行

   1. `static` -> `public`:
      static ディレクトリの名前を public に変更します。
   1     mv static public

   2. `store/` -> `stores/`:
      Vuex の store ディレクトリを Pinia の stores ディレクトリにリネームします。中のファイルは後続のステップで書き換えます。
   1     mv store stores

   3. `plugins/consts.js` -> `utils/consts.ts`:
      単純な定数をエクスポートしているプラグインは、Nuxt 3 の自動インポートが効く utils ディレクトリに移動するのが適しています。
   1     mkdir utils
   2     mv plugins/consts.js utils/consts.ts
      plugins ディレクトリが不要になった場合は削除します。

  ステップ 5: 状態管理の移行 (Vuex to Pinia)

  stores/ ディレクトリ内のファイルを Pinia のストア定義に書き換えます。一つのファイルにまとめるのが一般的です。

  `stores/weather.ts` (旧 `state.js`, `mutations.js`, `actions.js`, `getters.js` を統合):

    1 // stores/weather.ts
    2 import { defineStore } from 'pinia'
    3
    4 // APIレスポンスの型定義 (必要に応じて詳細化)
    5 interface WeatherData {
    6   // ... APIのレスポンスに応じた型を定義
    7 }
    8
    9 export const useWeatherStore = defineStore('weather', {
   10   state: () => ({
   11     // state
   12     city: '130010', // Tokyo
   13     weather: null as WeatherData | null,
   14     error: null as any,
   15     loading: false,
   16     currentView: 'list' // 'list' or 'detail'
   17   }),
   18
   19   getters: {
   20     // getters
   21     getForecastByDate: (state) => (date: string) => {
   22       return state.weather?.forecasts.find(f => f.date === date)
   23     },
   24     // ... 他のゲッター
   25   },
   26
   27   actions: {
   28     // actions
   29     async fetchWeather(cityCode: string) {
   30       this.loading = true
   31       this.error = null
   32       const config = useRuntimeConfig()
   33
   34       try {
   35         const data = await $fetch<WeatherData>(`/api/v1`, {
   36           baseURL: config.public.weatherApiBaseUrl,
   37           params: { city: cityCode }
   38         })
   39         this.weather = data
   40         this.city = cityCode
   41       } catch (e) {
   42         this.error = e
   43         this.weather = null
   44       } finally {
   45         this.loading = false
   46       }
   47     },
   48
   49     setCurrentView(view: 'list' | 'detail') {
   50       this.currentView = view
   51     },
   52
   53     setCity(cityCode: string) {
   54         this.city = cityCode
   55     }
   56   }
   57 })

  ステップ 6: Mixin から Composable への移行

  components/mixin.js のロジックを composables/useWeather.ts のようなファイルに切り出します。

  `composables/useWeather.ts`:

    1 // composables/useWeather.ts
    2 import { useWeatherStore } from '@/stores/weather'
    3 import { storeToRefs } from 'pinia'
    4
    5 export const useWeather = () => {
    6   const store = useWeatherStore()
    7
    8   // state や getters をリアクティブに参照するために storeToRefs を使う
    9   const { weather, city, currentView, error, loading } = storeToRefs(store)
   10
   11   // actions はそのままストアから呼び出せる
   12   const { fetchWeather, setCurrentView, setCity } = store
   13
   14   // Mixin にあったメソッドをここで定義する
   15   const getDay = (date: string) => {
   16     // ...日付処理
   17     const day = new Date(date).getDay()
   18     return ['日', '月', '火', '水', '木', '金', '土'][day]
   19   }
   20
   21   // ... 他のヘルパー関数
   22
   23   return {
   24     // コンポーネントで使う state, getters, actions, ヘルパーを返す
   25     weather,
   26     city,
   27     currentView,
   28     error,
   29     loading,
   30     fetchWeather,
   31     setCurrentView,
   32     setCity,
   33     getDay,
   34   }
   35 }

  ステップ 7: コンポーネントの書き換え

  全ての .vue ファイルを <script setup> を使った構文に書き換えます。

  例: `pages/index.vue`

    1 <template>
    2   <div>
    3     <component :is="activeComponent" />
    4   </div>
    5 </template>
    6
    7 <script setup lang="ts">
    8 import { computed, defineAsyncComponent } from 'vue'
    9 import { useWeather } from '@/composables/useWeather'
   10
   11 // Composable から状態を取得
   12 const { currentView } = useWeather()
   13
   14 // 動的コンポーネントの定義
   15 const ListComponent = defineAsyncComponent(() => import('@/components/List.vue'))
   16 const DetailComponent = defineAsyncComponent(() => import('@/components/Detail.vue'))
   17
   18 // currentView の値に応じて表示するコンポーネントを切り替える
   19 const activeComponent = computed(() => {
   20   return currentView.value === 'detail' ? DetailComponent : ListComponent
   21 })
   22 </script>

  例: `components/List.vue`

    1 <template>
    2   <div>
    3     <!-- ... テンプレート ... -->
    4     <div v-if="loading">Loading...</div>
    5     <div v-if="error">{{ error.message }}</div>
    6     <div v-if="weather">
    7       <!-- ... -->
    8     </div>
    9   </div>
   10 </template>
   11
   12 <script setup lang="ts">
   13 import { useWeather } from '@/composables/useWeather'
   14
   15 // Composable から必要なものを全て取り出す
   16 const { weather, loading, error, fetchWeather, setCity } = useWeather()
   17
   18 // フォームの入力と連携するためのリアクティブな参照
   19 const selectedCity = ref('130010')
   20
   21 const searchWeather = () => {
   22   setCity(selectedCity.value)
   23   fetchWeather(selectedCity.value)
   24 }
   25
   26 // 初期表示時にデータを取得
   27 onMounted(() => {
   28   if (!weather.value) {
   29     fetchWeather(selectedCity.value)
   30   }
   31 })
   32 </script>

  書き換えのポイント:
   - this.$store.state -> useWeather() から取得したリアクティブな ref を使う。
   - this.$store.dispatch('actionName') -> useWeather() から取得した actionName() を直接呼び出す。
   - mapState, mapGetters -> useWeather() と storeToRefs を使う。
   - created / mounted -> <script setup> 内のトップレベル、または onMounted フック内にロジックを記述する。
   - mixin -> useWeather() を各コンポーネントで呼び出す。

  ステップ 8: 動作確認

   1. 開発サーバーの起動:
   1     npm run dev
      ブラウザで http://localhost:3000 を開き、アプリケーションが意図通りに動作するか確認します。
       - 都市の選択
       - 天気情報の表示
       - 詳細画面への遷移

   2. リンターの実行:
      コードが規約に沿っているか確認します。
   1     npm run lint

   3. 本番ビルドの確認:
      ビルドが正常に完了することを確認します。
   1     npm run build

  3. まとめ

  上記の手順により、プロジェクトを Nuxt 3 にアップグレードできます。特に状態管理の移行 (Vuex -> Pinia) と Mixin から Composable
  への移行が中心的な作業となります。各コンポーネントを一つずつ丁寧に書き換えていくことが成功の鍵です。

  アップグレード後は、Nuxt Devtools を活用して、コンポーネントや状態のデバッグを効率的に行うことができます。